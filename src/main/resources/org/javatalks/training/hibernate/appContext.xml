<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd
       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">
  <!--You can specify dbname as env variable, or you can simply change the default value here to run with other dbs-->
  <context:property-placeholder location="/org/javatalks/training/hibernate/env/${dbname:hsqldb}.properties"
                                properties-ref="mappingProps"/>
  <!--you can define either xml or annotations to use either XML based mapping or Annotations based Mapping-->
  <import resource="classpath:/org/javatalks/training/hibernate/${mapping:xml}SessionFactory.xml"/>

  <!--We're wrapping our underlying data source with lazy one so that connection is not retrieved from the pool unless-->
  <!--it's really necessary. E.g. if Hibernate hits only cache, there is no need to fetch connection, but without lazy-->
  <!--data source, it will be actually fetched if service methods are marked with @Transactional-->
  <bean id="dataSource" class="org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy">
    <property name="defaultTransactionIsolationName" value="TRANSACTION_READ_COMMITTED"/>
    <property name="defaultAutoCommit" value="false"/>
    <property name="targetDataSource">
      <bean class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">
        <property name="driverClass" value="${jdbc.driverClassName}"/>
        <property name="jdbcUrl" value="${jdbc.url}"/>
        <property name="user" value="${jdbc.user}"/>
        <property name="password" value="${jdbc.password}"/>
        <property name="acquireRetryAttempts" value="1"/>
        <!--Every hour we'll be hitting DB to make sure MySQL doesn't kill the connection. By default if connection
            is idle for 8 hrs, MySQL kills it-->
        <property name="idleConnectionTestPeriod" value="3600"/>
        <!--This option is useful if threads are waiting for the connection from pool. Without this threads would wait
        forever and you're risking to get your app down if all the threads stuck.-->
        <property name="checkoutTimeout" value="10000"/>
      </bean>
    </property>
  </bean>

  <bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager">
    <property name="sessionFactory" ref="sessionFactory"/>
    <property name="validateExistingTransaction" value="true"/>
  </bean>

  <bean id="userDao" class="org.javatalks.training.hibernate.dao.BookDao">
    <constructor-arg index="0" ref="sessionFactory"/>
  </bean>
  <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
    <constructor-arg index="0" ref="dataSource"/>
  </bean>

  <util:properties id="hibernateProps">
    <!--will show SQL nicely formatted instead of a one-line format-->
    <prop key="hibernate.format_sql">true</prop>
    <!--will show hints on what query is executed and sometimes why: whether to load some collection or what-->
    <prop key="hibernate.use_sql_comments">true</prop>
    <prop key="hibernate.dialect">${hibernate.dialect}</prop>
    <prop key="hibernate.hbm2ddl.auto">create-drop</prop>
    <!--here is the size of batching-->
  </util:properties>
</beans>